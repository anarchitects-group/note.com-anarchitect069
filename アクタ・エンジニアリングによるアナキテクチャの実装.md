## アクタ・エンジニアリングによるアナキテクチャの実装

アクタ・エンジニアリングの具体例に入る前に, アクタ・エンジニアリングを用いてアナキテクチャを実装するとはどういうことなのかを振り返っておきます.

わたしたちは (わたしたちとは?)
群れたり, 群れなかったりしながら
少しでも楽しく
より生き生きと生きていくために
今ある硬い慣習, 道具, 技術, 制度などを (アーキテクチャ)
よりましなものに少しずつ組み替えていこう (アナキテクチャ)

としているのですが,

たくさんあり得るモデルの中から
アクタ・エンジニアリングをひとつの例として
アナキテクチャを実現するとはどういうことか
言葉にしてみようと思います.

アクタ・グラフに埋め込まれたアクタのひとつとして
(あたかも) 意志をもって (いるかのように) できることは

1. アクタを見つける (たくさん見つければいいというわけではない)
2. アクタの声を聴く (擬因果関係を作ろうとする)
3. 声を解釈する
4. 解釈に基づいて行為する (他のアクタに話しかける)
5. アクタを産出する (どんなアクタを? どうやって?)
6. アクタを世話する
7. (見える範囲での) アクタ・グラフを観察する (擬因果関係の影響を受ける)
8. (見える範囲での) アクタ・グラフを世話する (擬因果関係の影響を与える)

上記の 1-4 はそのアクタ自身についてのものです.
4-6 は他のアクタに対してのもので, 7-8 はアクタ・グラフに対するものです.

## ‹ソフトウェア› を巡るアクタ・グラフ

ソフトウェアというアクタは, どのように産出されるのか, その過程にはどのようなアクタが関わっているのかを見てみましょう.

_以下では, 例えば「なんとか」と名付けられる, ある (任意の) アクタを角引用符 (Unicode で言う single angle quote) で囲んで ‹なんとか› のように記すことにします_

今, わたしたちが知っている ‹ソフトウェア› は自然発生したりはしませんから, どのアクタかが ‹ソフトウェア› を産み出そうとするはずです.

そのアクタを ‹ソフトウェア産出者› と呼ぶことにしましょう. これはそういう種類の特定のアクタが存在するというわけではなく、あるアクタがその役割を果たそう, 演じようとしているという意味です.

‹ソフトウェア産出者› として ‹ひと› や ‹組織› が思い浮かぶでしょうが, 別の ‹ソフトウェア› やその他のアクタが ‹ソフトウェア› を産出する場合もあります.

‹ソフトウェア産出者› が ‹ソフトウェア› を産み出そうとするのは, 単にそうしたいからです. 特に理由は要りません.
他のアクタを支配したり, 他のアクタやアクタ・グラフを破壊したりしようとしない限り, ‹ソフトウェア› を生み出すのは, ‹ソフトウェア産出者› 次第です. それが仕事のためであれ, ただの思いつきや楽しみのためだとしても.

‹ソフトウェア産出者› は, ‹ソフトウェア› を産み出そうとしますが, その過程には, それ以外にも多くのアクタが関わっていることでしょう.

‹ソフトウェア› を産出する過程そのものがアクタ・グラフの中のひとつの生態系であり, 過程そのものが ‹ソフトウェア産出› というアクタになると考えます.
この過程が具体的にどのようなものになるかは, どのようなやり方で ‹ソフトウェア› を産出するかによって変わってきますから, そのいくつかについては, 後で見ることにします.

産出された ‹ソフトウェア› には, さらに他のアクタが関わってくるでしょう.

まず, 産出された ‹ソフトウェア› を利用する ‹ソフトウェア利用者› がいます.
また, 産出された ‹ソフトウェア› を世話し, 育てる ‹ソフトウェア世話者› もいます.

‹ソフトウェア› の内部, あるいは下位に目を向ければ, ‹ソフトウェア› を物理的に実行するための ‹ハードウェア› などのアクタもいるかもしれません.

_グラフ_

## アナキテクチャとしての ‹ソフトウェア›

上に述べたのは, アクタ・エンジニアリングの中でソフトウェアをどのように捉えているか, ということでした. 

アクタ・エンジニアリング自体は価値中立なモデルです. したがって, 上の説明はわたしたちの知っている「ソフトウェア」を, アクタ・エンジニアリングの用語で抽象的に言い換えたものに過ぎないように見えるかもしれません.

しかし, アナキテクチャのモデルの一つとしてのアクタ・エンジニアリングを考えるときには, アナキテクチャの原則に従う必要があります.

「アナキテクチャの原則」と聞いて, え, 何それ. そんな原則は今まで出てきていないのでは? と驚くかもしれません.

「アナキズムの定義」は前にも出て来ました. 「アナキテクチャの原則」とは, アナキズムを実現する技術が守るべき規範と言えばいいでしょうか. でも, それは決して「原理」ではありません. 状況に応じて変わるかもしれないものであって, 天下りに与えられるものではなく, みなでその場その場で話して考えて納得していくもので, だから, 今こうして, アクタ・エンジニアリングを具体的に考えながら, アナキテクチャ = 形のない形の原則も考えている最中なのです.

例えば, 「その ‹ソフトウェア› の ‹ソフトウェア利用者› となりたい/なろうとするアクタが, その ‹ソフトウェア› の ‹ソフトウェア産出者› になる」という原則を考えてみましょう.
つまり, 自分で使うわけでもなく, 使いたくもない ‹ソフトウェア› を産出するべきではない, ということです.

そんな原則が出てきた根拠はどこにあるのでしょうか? 原則なんてものは少なければ少ない方がいいので, みなが納得できる何らかの根拠があって然るべきです.

