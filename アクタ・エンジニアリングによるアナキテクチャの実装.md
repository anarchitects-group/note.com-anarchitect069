## アクタ・エンジニアリングによるアナキテクチャの実装

アクタ・エンジニアリングの具体例に入る前に, アクタ・エンジニアリングを用いてアナキテクチャを実装するとはどういうことなのかを振り返っておきます.

わたしたちは (わたしたちとは?)
群れたり, 群れなかったりしながら
少しでも楽しく
より生き生きと生きていくために
今ある硬い慣習, 道具, 技術, 制度などを (アーキテクチャ)
よりましなものに少しずつ組み替えていこう (アナキテクチャ)

としているのですが,

たくさんあり得るモデルの中から
アクタ・エンジニアリングをひとつの例として
アナキテクチャを実現するとはどういうことか
言葉にしてみようと思います.

アクタ・グラフに埋め込まれたアクタのひとつとして
(あたかも) 意志をもって (いるかのように) できることは

1. アクタを見つける (たくさん見つければいいというわけではない)
2. アクタの声を聴く (擬因果関係を作ろうとする)
3. 声を解釈する
4. 解釈に基づいて行為する (他のアクタに話しかける)
5. アクタを産出する (どんなアクタを? どうやって?)
6. アクタを育てる
7. アクタを世話する
8. (見える範囲での) アクタ・グラフを観察する (擬因果関係の影響を受ける)
9. (見える範囲での) アクタ・グラフをケアする (擬因果関係の影響を与える)

上記の 1-4 はそのアクタ自身についてのものです.
4-7 は他のアクタに対してのもので, 8-9 はアクタ・グラフに対するものです.

## ‹ソフトウェア› を巡るアクタ・グラフ

「ソフトウェア」というアクタがあるとして, そのアクタは, アクタ・グラフの中でどのように現れるのでしょうか?
ここではまず, 簡単に想像してみましょう. そして, その過程から逆にアナキテクチャとはどういうものかを考えていきたいと思います.

_以下では, 例えば「なんとか」と名付けられる, ある (任意の) アクタを角引用符 (Unicode で言う single angle quote) で囲んで ‹なんとか› のように記すことにします_

### ‹ソフトウェア産出者›

ソフトウェア産出者というアクタ (‹ソフトウェア産出者›) は, ソフトウェアというアクタを産み出すアクタです.

‹ソフトウェア› はもしかしたら自然発生するものかもしれませんが, 今のわたしたちが知っている ‹ソフトウェア› は誰か (‹ソフトウェア産出者›) が産み出すものです.

そのような ‹ソフトウェア産出者› として, ‹ひと› や ‹組織› だけではなく, ‹ソフトウェア› や他のアクタの場合もあります.

```anarchitecture
アナキテクチャの考えでは, ‹ソフトウェア産出者› は, その ‹ソフトウェア› を必要とするアクタでなければならない.
その必要性が, 仕事のためか, 遊びのためか, などは問わないが, ひとを支配したり, ひとに押し付けたりするためのものであるべきではない
```

```anarchitecture
アナキテクチャの考えでは, ‹ソフトウェア産出者› は自ら ‹ソフトウェア› を産出するべきである.
もし, ある時点でその能力が不足しているのならば, いくつかの方法がある
        1. その能力を身に付けるようにアクタが発達 (学習) する
        2. その能力を持つ他のアクタと協調する (そのアクタを含む, 大きなアクタを形成する)
        3. 必要とするもの, あるいは代替品を探し出す (そのために「バザール」がある)
```

### ‹ソフトウェア利用者› ‹ソフトウェア世話者›

このアナキテクチャの原則に従えば, ‹ソフトウェア産出者› は, 少なくとも, その ‹ソフトウェア› が産出された時点では, ‹ソフトウェア利用者› でもなければならないということになります.

‹ソフトウェア利用者› が ‹ソフトウェア産出者› ではあるとは限りませんが, ‹ソフトウェア利用者› は ‹ソフトウェア› の利用を通じて, ‹ソフトウェア› あるいは ‹ソフトウェア› を含むアクタ・グラフを育てていきます.

```anarchitecture
アナキテクチャの考えでは, ‹ソフトウェア› を利用するアクタは, ‹ソフトウェア› あるいはその ‹ソフトウェア› を含むアクタ・グラフを世話するアクタでもあるべきである.
```
